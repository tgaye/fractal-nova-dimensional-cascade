<!DOCTYPE html><html><head><meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fractal Nova: Dimensional Cascade</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Arial', sans-serif;
        }
        #canvas-container {
            width: 100%;
            max-width: 1200px;
            height: 100vh;
            margin: 0 auto;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        #ui-container {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            color: white;
            max-width: 300px;
            z-index: 100;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .control-group {
            margin-bottom: 15px;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }
        .control-group input[type="range"] {
            width: 100%;
        }
        .value-display {
            font-size: 12px;
            color: #aaa;
            margin-top: 3px;
        }
        button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
            margin-bottom: 5px;
            font-size: 12px;
        }
        button:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        #toggle-ui {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 101;
        }
        #error-message {
            color: white;
            text-align: center;
            padding: 20px;
            font-size: 18px;
        }
    </style>

<base target="_self">


    </head><body><div id="canvas-container">
        <div id="error-message"></div>
    </div>
    <button id="toggle-ui">Toggle UI</button>
    <div id="ui-container">
        <h3>Fractal Controls</h3>
        
        <div class="control-group">
            <label for="fractal-iterations">Iterations</label>
            <input type="range" id="fractal-iterations" min="1" max="20" step="1" value="8">
            <div class="value-display" id="iterations-value">8</div>
        </div>
        
        <div class="control-group">
            <label for="fractal-power">Power</label>
            <input type="range" id="fractal-power" min="2" max="10" step="0.1" value="8">
            <div class="value-display" id="power-value">8.0</div>
        </div>
        
        <div class="control-group">
            <label for="fractal-scale">Scale</label>
            <input type="range" id="fractal-scale" min="0.5" max="2" step="0.01" value="1.0">
            <div class="value-display" id="scale-value">1.0</div>
        </div>
        
        <div class="control-group">
            <label for="color-primary">Primary Color</label>
            <input type="color" id="color-primary" value="#5d00ff">
        </div>
        
        <div class="control-group">
            <label for="color-secondary">Secondary Color</label>
            <input type="color" id="color-secondary" value="#ff00a2">
        </div>
        
        <div class="control-group">
            <label for="light-intensity">Light Intensity</label>
            <input type="range" id="light-intensity" min="0" max="2" step="0.01" value="1.0">
            <div class="value-display" id="light-value">1.0</div>
        </div>
        
        <div class="control-group">
            <label for="audio-reactivity">Audio Reactivity</label>
            <input type="range" id="audio-reactivity" min="0" max="1" step="0.01" value="0.5">
            <div class="value-display" id="audio-value">0.5</div>
        </div>
        
        <div class="control-group">
            <label for="speed">Animation Speed</label>
            <input type="range" id="speed" min="0" max="2" step="0.01" value="0.5">
            <div class="value-display" id="speed-value">0.5</div>
        </div>
        
        <div class="preset-buttons">
            <button id="preset1">Electric</button>
            <button id="preset2">Organic</button>
            <button id="preset3">Cosmic</button>
            <button id="reset">Reset</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
    <script>
        // Check for WebGL support
        if (!window.WebGLRenderingContext) {
            document.getElementById('error-message').innerHTML = 
                'Your browser does not support WebGL. Please try with a modern browser like Chrome or Firefox.';
            throw new Error('WebGL not supported');
        }

        // Main variables
        let scene, camera, renderer, material, mesh, clock;
        let mouseX = 0, mouseY = 0;
        let audioContext, analyser, audioData, isAudioPlaying = false;
        let params = {
            iterations: 8,
            power: 8.0,
            scale: 1.0,
            primaryColor: new THREE.Color(0x5d00ff),
            secondaryColor: new THREE.Color(0xff00a2),
            lightIntensity: 1.0,
            audioReactivity: 0.5,
            speed: 0.5
        };

        // Initialize Three.js
        function init() {
            // Create scene
            scene = new THREE.Scene();

            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 2;

            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            updateRendererSize();
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Create clock for animations
            clock = new THREE.Clock();

            // Create geometry
            const geometry = new THREE.PlaneGeometry(2, 2);

            // Shader material
            material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                    mouse: { value: new THREE.Vector2(0, 0) },
                    iterations: { value: params.iterations },
                    power: { value: params.power },
                    scale: { value: params.scale },
                    primaryColor: { value: params.primaryColor },
                    secondaryColor: { value: params.secondaryColor },
                    lightIntensity: { value: params.lightIntensity },
                    audioReactivity: { value: params.audioReactivity },
                    audioData: { value: new Float32Array(32) },
                    speed: { value: params.speed }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    precision highp float;
                    uniform float time;
                    uniform vec2 resolution;
                    uniform vec2 mouse;
                    uniform int iterations;
                    uniform float power;
                    uniform float scale;
                    uniform vec3 primaryColor;
                    uniform vec3 secondaryColor;
                    uniform float lightIntensity;
                    uniform float audioReactivity;
                    uniform float audioData[32];
                    uniform float speed;

                    varying vec2 vUv;

                    // 3D noise function (simplex)
                    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                    vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

                    float snoise(vec3 v) {
                        const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

                        vec3 i = floor(v + dot(v, C.yyy));
                        vec3 x0 = v - i + dot(i, C.xxx);

                        vec3 g = step(x0.yzx, x0.xyz);
                        vec3 l = 1.0 - g;
                        vec3 i1 = min(g.xyz, l.zxy);
                        vec3 i2 = max(g.xyz, l.zxy);

                        vec3 x1 = x0 - i1 + C.xxx;
                        vec3 x2 = x0 - i2 + C.yyy;
                        vec3 x3 = x0 - D.yyy;

                        i = mod289(i);
                        vec4 p = permute(permute(permute(
                                    i.z + vec4(0.0, i1.z, i2.z, 1.0))
                                + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                                + i.x + vec4(0.0, i1.x, i2.x, 1.0));

                        float n_ = 0.142857142857;
                        vec3 ns = n_ * D.wyz - D.xzx;

                        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);

                        vec4 x_ = floor(j * ns.z);
                        vec4 y_ = floor(j - 7.0 * x_);

                        vec4 x = x_ * ns.x + ns.yyyy;
                        vec4 y = y_ * ns.x + ns.yyyy;
                        vec4 h = 1.0 - abs(x) - abs(y);

                        vec4 b0 = vec4(x.xy, y.xy);
                        vec4 b1 = vec4(x.zw, y.zw);

                        vec4 s0 = floor(b0)*2.0 + 1.0;
                        vec4 s1 = floor(b1)*2.0 + 1.0;
                        vec4 sh = -step(h, vec4(0.0));

                        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;

                        vec3 p0 = vec3(a0.xy, h.x);
                        vec3 p1 = vec3(a0.zw, h.y);
                        vec3 p2 = vec3(a1.xy, h.z);
                        vec3 p3 = vec3(a1.zw, h.w);

                        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                        p0 *= norm.x;
                        p1 *= norm.y;
                        p2 *= norm.z;
                        p3 *= norm.w;

                        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                        m = m * m;
                        return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
                    }

                    // Fractal distance function (Mandelbulb variation)
                    float fractalDistance(vec3 pos) {
                        vec3 z = pos;
                        float dr = 1.0;
                        float r = 0.0;
                        float power = power + audioData[0] * 2.0 * audioReactivity;
                        
                        for (int i = 0; i < 20; i++) {
                            if (i >= iterations) break;
                            
                            r = length(z);
                            if (r > 2.0) break;
                            
                            // Convert to polar coordinates
                            float theta = acos(z.z/r) * power;
                            float phi = atan(z.y, z.x) * power;
                            float zr = pow(r, power);
                            
                            dr = pow(r, power-1.0)*power*dr + 1.0;
                            
                            // Convert back to cartesian coordinates
                            z = zr * vec3(sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta));
                            z += pos;
                        }
                        
                        return 0.5 * log(r) * r / dr;
                    }

                    // Calculate normal using central differences
                    vec3 calculateNormal(vec3 pos) {
                        const float eps = 0.001;
                        vec2 e = vec2(1.0, -1.0) * eps;
                        
                        return normalize(
                            e.xyy * fractalDistance(pos + e.xyy) + 
                            e.yyx * fractalDistance(pos + e.yyx) + 
                            e.yxy * fractalDistance(pos + e.yxy) + 
                            e.xxx * fractalDistance(pos + e.xxx)
                        );
                    }

                    // Soft shadow calculation
                    float softShadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {
                        float res = 1.0;
                        float t = mint;
                        for(int i = 0; i < 32; i++) {
                            if(t >= maxt) break;
                            float h = fractalDistance(ro + rd * t);
                            if(h < 0.001) return 0.0;
                            res = min(res, k * h / t);
                            t += h;
                        }
                        return res;
                    }

                    // Ambient occlusion approximation
                    float ambientOcclusion(vec3 pos, vec3 nor) {
                        float occ = 0.0;
                        float sca = 1.0;
                        for(int i = 0; i < 5; i++) {
                            float hr = 0.01 + 0.12 * float(i) / 4.0;
                            vec3 aopos = nor * hr + pos;
                            float dd = fractalDistance(aopos);
                            occ += -(dd - hr) * sca;
                            sca *= 0.95;
                        }
                        return clamp(1.0 - 3.0 * occ, 0.0, 1.0);
                    }

                    void main() {
                        // Normalized pixel coordinates (from 0 to 1)
                        vec2 uv = vUv;
                        
                        // Center and aspect ratio correction
                        vec2 p = (2.0 * vUv - 1.0) * vec2(resolution.x / resolution.y, 1.0);
                        
                        // Mouse influence
                        vec2 mousePos = (2.0 * mouse - 1.0) * vec2(resolution.x / resolution.y, 1.0);
                        
                        // Camera setup
                        vec3 ro = vec3(0.0, 0.0, 3.0);
                        vec3 rd = normalize(vec3(p, -2.0));
                        
                        // Apply rotation based on mouse and time
                        float t = time * speed * 0.5;
                        float mx = mousePos.x * 3.14 + t * 0.1;
                        float my = (mousePos.y * 0.5 + 0.5) * 3.14 * 0.25 + sin(t * 0.3) * 0.2;
                        
                        mat2 rotX = mat2(cos(my), -sin(my), sin(my), cos(my));
                        mat2 rotY = mat2(cos(mx), -sin(mx), sin(mx), cos(mx));
                        
                        rd.xy = rotY * rd.xy;
                        rd.xz = rotX * rd.xz;
                        ro.xy = rotY * ro.xy;
                        ro.xz = rotX * ro.xz;
                        
                        // Ray marching
                        float d, td = 0.0;
                        vec3 pos = ro;
                        float glow = 0.0;
                        
                        for(int i = 0; i < 100; i++) {
                            pos = ro + rd * td;
                            d = fractalDistance(pos * scale);
                            if(d < 0.001 || td > 20.0) break;
                            td += d;
                            glow += 0.02 / (0.1 + d * 5.0);
                        }
                        
                        // Lighting
                        vec3 color = vec3(0.0);
                        
                        if(d < 0.001) {
                            // Surface normal
                            vec3 n = calculateNormal(pos);
                            
                            // Light position (animated)
                            vec3 lightPos = vec3(2.0 * sin(t * 0.5), 1.5 + cos(t * 0.4), 2.0 * cos(t * 0.3));
                            
                            // Light direction
                            vec3 l = normalize(lightPos - pos);
                            
                            // Diffuse lighting
                            float diff = clamp(dot(n, l), 0.0, 1.0);
                            
                            // Specular lighting
                            vec3 h = normalize(l - rd);
                            float spec = pow(clamp(dot(n, h), 0.0, 1.0), 32.0);
                            
                            // Shadows
                            float shadow = softShadow(pos + n * 0.01, l, 0.02, 10.0, 8.0);
                            
                            // Ambient occlusion
                            float ao = ambientOcclusion(pos, n);
                            
                            // Combine lighting
                            vec3 baseColor = mix(primaryColor, secondaryColor, 0.5 + 0.5 * sin(pos.x * 2.0 + t));
                            color = baseColor * diff * shadow * lightIntensity;
                            color += vec3(0.8) * spec * shadow * lightIntensity;
                            color *= ao;
                            
                            // Add glow from steps
                            color += glow * 0.5 * vec3(0.5, 0.8, 1.0) * (0.5 + 0.5 * audioData[1]);
                        } else {
                            // Background with audio reactivity
                            float audioWave = audioData[2] * 0.5 * audioReactivity;
                            color = mix(vec3(0.05, 0.05, 0.1), vec3(0.1, 0.05, 0.2), uv.y + audioWave);
                            
                            // Add glow from steps
                            color += glow * 0.3 * vec3(0.3, 0.5, 1.0) * (0.5 + 0.5 * audioData[3]);
                        }
                        
                        // Add noise for texture
                        float noise = snoise(vec3(uv * 20.0, t * 0.5)) * 0.02;
                        color += noise;
                        
                        // Vignette
                        vec2 vignette = uv * (1.0 - uv);
                        float vig = vignette.x * vignette.y * 15.0;
                        vig = pow(vig, 0.25);
                        color *= vig;
                        
                        // Output to screen
                        gl_FragColor = vec4(color, 1.0);
                    }
                `,
                transparent: false,
                depthTest: false
            });

            // Create mesh
            mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);

            // Setup audio analyzer
            setupAudio();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('touchmove', onTouchMove, { passive: false });

            // UI controls
            setupUI();

            // Start animation loop
            animate();
        }

        // Update renderer size
        function updateRendererSize() {
            const container = document.getElementById('canvas-container');
            const width = Math.min(container.clientWidth, 1200);
            const height = width * (9 / 16);
            
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            
            if (material) {
                material.uniforms.resolution.value.set(width, height);
            }
        }

        // Window resize handler
        function onWindowResize() {
            updateRendererSize();
        }

        // Mouse move handler
        function onMouseMove(event) {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            
            if (material) {
                material.uniforms.mouse.value.set(
                    event.clientX / window.innerWidth,
                    1.0 - (event.clientY / window.innerHeight)
                );
            }
        }

        // Touch move handler
        function onTouchMove(event) {
            event.preventDefault();
            if (event.touches.length > 0) {
                mouseX = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
                mouseY = -(event.touches[0].clientY / window.innerHeight) * 2 + 1;
                
                if (material) {
                    material.uniforms.mouse.value.set(
                        event.touches[0].clientX / window.innerWidth,
                        1.0 - (event.touches[0].clientY / window.innerHeight)
                    );
                }
            }
        }

        // Setup audio analyzer
        function setupAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 64;
                audioData = new Float32Array(analyser.frequencyBinCount);
                
                // Try to get microphone input
                navigator.mediaDevices.getUserMedia({ audio: true, video: false })
                    .then(function(stream) {
                        const source = audioContext.createMediaStreamSource(stream);
                        source.connect(analyser);
                        isAudioPlaying = true;
                    })
                    .catch(function(err) {
                        console.log('Audio input not available:', err);
                        // Create oscillator as fallback
                        const oscillator = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        oscillator.connect(gain);
                        gain.connect(analyser);
                        oscillator.type = 'sine';
                        oscillator.frequency.value = 440;
                        gain.gain.value = 0.1;
                        oscillator.start();
                        isAudioPlaying = true;
                    });
            } catch (e) {
                console.log('Web Audio API not supported:', e);
                // Fallback: generate fake audio data
                isAudioPlaying = false;
                audioData = new Float32Array(32);
                setInterval(function() {
                    for (let i = 0; i < audioData.length; i++) {
                        audioData[i] = Math.random() * 0.5 + Math.sin(Date.now() * 0.001 + i * 0.3) * 0.5;
                    }
                }, 100);
            }
        }

        // Setup UI controls
        function setupUI() {
            // Slider controls
            document.getElementById('fractal-iterations').addEventListener('input', function(e) {
                params.iterations = parseInt(e.target.value);
                material.uniforms.iterations.value = params.iterations;
                document.getElementById('iterations-value').textContent = params.iterations;
            });
            
            document.getElementById('fractal-power').addEventListener('input', function(e) {
                params.power = parseFloat(e.target.value);
                material.uniforms.power.value = params.power;
                document.getElementById('power-value').textContent = params.power.toFixed(1);
            });
            
            document.getElementById('fractal-scale').addEventListener('input', function(e) {
                params.scale = parseFloat(e.target.value);
                material.uniforms.scale.value = params.scale;
                document.getElementById('scale-value').textContent = params.scale.toFixed(2);
            });
            
            document.getElementById('color-primary').addEventListener('input', function(e) {
                params.primaryColor.setStyle(e.target.value);
                material.uniforms.primaryColor.value = params.primaryColor;
            });
            
            document.getElementById('color-secondary').addEventListener('input', function(e) {
                params.secondaryColor.setStyle(e.target.value);
                material.uniforms.secondaryColor.value = params.secondaryColor;
            });
            
            document.getElementById('light-intensity').addEventListener('input', function(e) {
                params.lightIntensity = parseFloat(e.target.value);
                material.uniforms.lightIntensity.value = params.lightIntensity;
                document.getElementById('light-value').textContent = params.lightIntensity.toFixed(2);
            });
            
            document.getElementById('audio-reactivity').addEventListener('input', function(e) {
                params.audioReactivity = parseFloat(e.target.value);
                material.uniforms.audioReactivity.value = params.audioReactivity;
                document.getElementById('audio-value').textContent = params.audioReactivity.toFixed(2);
            });
            
            document.getElementById('speed').addEventListener('input', function(e) {
                params.speed = parseFloat(e.target.value);
                material.uniforms.speed.value = params.speed;
                document.getElementById('speed-value').textContent = params.speed.toFixed(2);
            });
            
            // Preset buttons
            document.getElementById('preset1').addEventListener('click', function() {
                // Electric preset
                params.iterations = 10;
                params.power = 6.0;
                params.scale = 1.2;
                params.primaryColor.setStyle('#5d00ff');
                params.secondaryColor.setStyle('#00ffa2');
                params.lightIntensity = 1.5;
                params.audioReactivity = 0.8;
                params.speed = 0.7;
                updateUIFromParams();
            });
            
            document.getElementById('preset2').addEventListener('click', function() {
                // Organic preset
                params.iterations = 6;
                params.power = 3.0;
                params.scale = 0.8;
                params.primaryColor.setStyle('#ff5d00');
                params.secondaryColor.setStyle('#a200ff');
                params.lightIntensity = 0.8;
                params.audioReactivity = 0.3;
                params.speed = 0.3;
                updateUIFromParams();
            });
            
            document.getElementById('preset3').addEventListener('click', function() {
                // Cosmic preset
                params.iterations = 12;
                params.power = 8.0;
                params.scale = 1.5;
                params.primaryColor.setStyle('#0000ff');
                params.secondaryColor.setStyle('#ff00a2');
                params.lightIntensity = 1.2;
                params.audioReactivity = 0.5;
                params.speed = 0.5;
                updateUIFromParams();
            });
            
            document.getElementById('reset').addEventListener('click', function() {
                // Reset to defaults
                params.iterations = 8;
                params.power = 8.0;
                params.scale = 1.0;
                params.primaryColor.setStyle('#5d00ff');
                params.secondaryColor.setStyle('#ff00a2');
                params.lightIntensity = 1.0;
                params.audioReactivity = 0.5;
                params.speed = 0.5;
                updateUIFromParams();
            });
            
            // Toggle UI button
            document.getElementById('toggle-ui').addEventListener('click', function() {
                const ui = document.getElementById('ui-container');
                ui.style.display = ui.style.display === 'none' ? 'block' : 'none';
            });
        }
        
        // Update UI controls from params
        function updateUIFromParams() {
            document.getElementById('fractal-iterations').value = params.iterations;
            document.getElementById('fractal-power').value = params.power;
            document.getElementById('fractal-scale').value = params.scale;
            document.getElementById('color-primary').value = params.primaryColor.getHexString();
            document.getElementById('color-secondary').value = params.secondaryColor.getHexString();
            document.getElementById('light-intensity').value = params.lightIntensity;
            document.getElementById('audio-reactivity').value = params.audioReactivity;
            document.getElementById('speed').value = params.speed;
            
            document.getElementById('iterations-value').textContent = params.iterations;
            document.getElementById('power-value').textContent = params.power.toFixed(1);
            document.getElementById('scale-value').textContent = params.scale.toFixed(2);
            document.getElementById('light-value').textContent = params.lightIntensity.toFixed(2);
            document.getElementById('audio-value').textContent = params.audioReactivity.toFixed(2);
            document.getElementById('speed-value').textContent = params.speed.toFixed(2);
            
            material.uniforms.iterations.value = params.iterations;
            material.uniforms.power.value = params.power;
            material.uniforms.scale.value = params.scale;
            material.uniforms.primaryColor.value = params.primaryColor;
            material.uniforms.secondaryColor.value = params.secondaryColor;
            material.uniforms.lightIntensity.value = params.lightIntensity;
            material.uniforms.audioReactivity.value = params.audioReactivity;
            material.uniforms.speed.value = params.speed;
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update time
            material.uniforms.time.value = clock.getElapsedTime();
            
            // Update audio data
            if (isAudioPlaying && analyser) {
                analyser.getFloatFrequencyData(audioData);
                // Normalize audio data
                for (let i = 0; i < audioData.length; i++) {
                    audioData[i] = (audioData[i] + 140) / 140; // Convert from dB to 0-1 range
                    audioData[i] = Math.max(0, Math.min(1, audioData[i]));
                }
            }
            
            if (material.uniforms.audioData) {
                material.uniforms.audioData.value = audioData;
            }
            
            // Render scene
            renderer.render(scene, camera);
        }

        // Start the application
        init();
    </script>

              
          
                
          
              
</body></html>